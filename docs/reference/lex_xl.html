<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Parse Excel formulas into tokens — lex_xl • lexl</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">


<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>
  
  
<!-- mathjax -->
<script src='https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">lexl</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="..//index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/dev-notes.html">Developer Notes</a>
    </li>
    <li>
      <a href="../articles/lex-xl.html">Tokenise Excel Formulas</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

      <div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Parse Excel formulas into tokens</h1>
    </div>

    
    <p><code>lex_xl</code> takes an Excel formula and separates it into tokens.  It returns a
dataframe, one row per token, giving the token itself, its type (e.g.
<code>number</code>, or <code>error</code>), and its level.</p>
<p>The level is a number to show the depth of a token within nested function
calls.  The token <code>A2</code> in the formula <code>IF(A1=1,A2,MAX(A3,A4))</code> is at level 1.
Tokens <code>A3</code> and <code>A4</code> are at level 2.  The token <code>IF</code> is at level 0, which is
the outermost level.</p>
<p>The output isn't enough to enable computation or validation of formulas, but
it is enough to investigate the structure of formulas and spreadsheets.  It
has been tested on millions of formulas in the Enron corpus.</p>
    

    <pre class="usage"><span class='fu'>lex_xl</span>(<span class='no'>x</span>)</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a> Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>x</th>
      <td><p>Character vector of length 1, giving the formula.</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>A data frame (a tibble, if you use the tidyverse) one row per token,
giving the token itself, its type (e.g.  <code>number</code>, or <code>error</code>), and its
level.</p>
    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>The different types of tokens are:</p><ul>
<li><p><code>ref</code> A cell reference/address e.g. <code>A1</code> or <code>$B2:C$14</code>.</p></li>
<li><p><code>sheet</code>A sheet name, e.g. <code>Sheet1!</code> or <code>'My Sheet'!</code>.  If the sheet is
from a different file, then the file is included in this token -- usually
it has been normalized to the form <code>[0]</code>.</p></li>
<li><p><code>name</code> A named range, or more properly a named formula.</p></li>
<li><p><code>function</code> An Excel or user-defined function, e.g. <code>MAX</code> or
<code>_xll.MY_CUSTOM_FUNCTION</code>.  A complete list of official Excel functions is
available in the vector <code><a href='excel_functions.html'>excel_functions</a></code>.</p></li>
<li><p><code>error</code> An error, e.g. <code>#N/A</code> or <code>#REF!</code>.</p></li>
<li><p><code>bool</code> <code>TRUE</code> or <code>FALSE</code> -- note that there are also functions <code>TRUE()</code> and
<code>FALSE()</code>.</p></li>
<li><p><code>number</code> All forms of numbers, e.g. <code>1</code>, <code>1.1</code>, <code>-1</code>, <code>1.2E3</code>.</p></li>
<li><p><code>text</code> Strings inside double quotes, e.g. <code>"Hello, World!"</code>.</p></li>
<li><p><code>operator</code> The usual infix operators, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, <code>&amp;lt;</code>, <code>&amp;lt;=</code>,
<code>&amp;lt;&amp;gt;</code>, etc.  and also the range operator <code>:</code> when it is used with ranges
that aren't cell addresses, e.g. <code>INDEX(something):A1</code>. The union operator
<code>,</code> is the same symbol that is used to separate function arguments and
array columns, so it is only tagged <code>operator</code> when it is inside
parentheses that are not function parentheses or array curly braces (see
the examples).</p></li>
<li><p><code>paren_open</code> An open parenthesis <code>(</code> indicating an increase in the level
of nesting, but not directly enclosing function arguments.</p></li>
<li><p><code>paren_close</code> As <code>open</code>, but reducing the level of nesting.</p></li>
<li><p><code>open_array</code> An open curly brace '{' indicating the start of an array
of constants, and an increase in the level of nesting.</p></li>
<li><p><code>close_array</code> As <code>open_array</code>, but ending the array of constants</p></li>
<li><p><code>fun_open</code> An open parenthesis <code>(</code> immediately after a function name,
directly enclosing the function arguments.</p></li>
<li><p><code>fun_close</code> As <code>fun_open</code> but immediately after the function
arguments.</p></li>
<li><p><code>separator</code> A comma <code>,</code> separating function arguments or array
columns, or a semicolon <code>;</code> separating array rows.</p></li>
<li><p><code>DDE</code> A call to a Dynamic Data Exchange server, usually normalized to
the form <code>[1]!'DDE_parameter=1'</code>, but the full form is
<code>'ABCD'|'EFGH'!'IJKL'</code>.</p></li>
<li><p><code>space</code> Some old files haven't stripped formulas of meaningless
spaces. They are returned as <code>space</code> tokens so that the original formula
can always be reconstructed by concatenating all tokens.</p></li>
<li><p><code>other</code> If you see this, then something has gone wrong -- please
report it at https://github.com/nacnudus/lexl/issues with a
reproducible example (e.g. using the reprex package).</p></li>
</ul>
    <p>Every part of the original formula is returned as a token, so the original
formula can be reconstructed by concatenating the tokens.  If that doesn't
work, please report it at https://github.com/nacnudus/lexl/issues with a
reproducible example (e.g. using the reprex package).</p>
<p>The XLParser project was a great help in creating the grammar.
https://github.com/spreadsheetlab/XLParser.</p>
    
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <p><code><a href='lexl_igraph.html'>plot()</a></code>, <code><a href='demo_lexl.html'>lexl::demo_lexl()</a></code></p>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'># All explicit cell references/addresses are returned as a single 'ref'</span>
<span class='co'># token.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"A1"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   ref    A1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"A$1"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   ref   A$1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"$A1"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   ref   $A1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"$A$1"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   ref  $A$1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"A1:B2"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   ref A1:B2</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"1:1"</span>) <span class='co'># Whole row</span></div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   ref   1:1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"A:B"</span>) <span class='co'># Whole column</span></div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   ref   A:B</div><div class='input'>
<span class='co'># If one part of an address is a name or a function, then the colon ':' is</span>
<span class='co'># regarded as a 'range operator', so is tagged 'operator'.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"A1:SOME.NAME"</span>)</div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level     type     token
#&gt;   &lt;int&gt;    &lt;chr&gt;     &lt;chr&gt;
#&gt; 1     0      ref        A1
#&gt; 2     0 operator         :
#&gt; 3     0     name SOME.NAME</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"SOME_FUNCTION():B2"</span>)</div><div class='output co'>#&gt; # A tibble: 5 x 3
#&gt;   level      type         token
#&gt;   &lt;int&gt;     &lt;chr&gt;         &lt;chr&gt;
#&gt; 1     0  function SOME_FUNCTION
#&gt; 2     0  fun_open             (
#&gt; 3     0 fun_close             )
#&gt; 4     0  operator             :
#&gt; 5     0       ref            B2</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"SOME_FUNCTION():SOME.NAME"</span>)</div><div class='output co'>#&gt; # A tibble: 5 x 3
#&gt;   level      type         token
#&gt;   &lt;int&gt;     &lt;chr&gt;         &lt;chr&gt;
#&gt; 1     0  function SOME_FUNCTION
#&gt; 2     0  fun_open             (
#&gt; 3     0 fun_close             )
#&gt; 4     0  operator             :
#&gt; 5     0      name     SOME.NAME</div><div class='input'>
<span class='co'># Sheet names are recognised by the terminal exclamation mark '!'.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"Sheet1!A1"</span>)</div><div class='output co'>#&gt; # A tibble: 2 x 3
#&gt;   level  type   token
#&gt;   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;
#&gt; 1     0 sheet Sheet1!
#&gt; 2     0   ref      A1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"'Sheet 1'!A1"</span>)       <span class='co'># Quoted names may contain some punctuation</span></div><div class='output co'>#&gt; # A tibble: 2 x 3
#&gt;   level  type      token
#&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;
#&gt; 1     0 sheet 'Sheet 1'!
#&gt; 2     0   ref         A1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"'It''s a sheet'!A1"</span>) <span class='co'># Quotes are escaped by doubling</span></div><div class='output co'>#&gt; # A tibble: 2 x 3
#&gt;   level  type            token
#&gt;   &lt;int&gt; &lt;chr&gt;            &lt;chr&gt;
#&gt; 1     0 sheet 'It''s a sheet'!
#&gt; 2     0   ref               A1</div><div class='input'>
<span class='co'># Sheets can be ranged together in so-called 'three-dimensional formulas'.</span>
<span class='co'># Both sheets are returned in a single 'sheet' token.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"Sheet1:Sheet2!A1"</span>)</div><div class='output co'>#&gt; # A tibble: 2 x 3
#&gt;   level  type          token
#&gt;   &lt;int&gt; &lt;chr&gt;          &lt;chr&gt;
#&gt; 1     0 sheet Sheet1:Sheet2!
#&gt; 2     0   ref             A1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"'Sheet 1:Sheet 2'!A1"</span>) <span class='co'># Quotes surround both sheets (not each)</span></div><div class='output co'>#&gt; # A tibble: 2 x 3
#&gt;   level  type              token
#&gt;   &lt;int&gt; &lt;chr&gt;              &lt;chr&gt;
#&gt; 1     0 sheet 'Sheet 1:Sheet 2'!
#&gt; 2     0   ref                 A1</div><div class='input'>
<span class='co'># Sheets from other files are prefixed by the filename, which Excel</span>
<span class='co'># normalizes the filenames into indexes.  Either way, lex_xl() includes the</span>
<span class='co'># file/index in the 'sheet' token.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"[1]Sheet1!A1"</span>)</div><div class='output co'>#&gt; # A tibble: 2 x 3
#&gt;   level  type      token
#&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;
#&gt; 1     0 sheet [1]Sheet1!
#&gt; 2     0   ref         A1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"'[1]Sheet 1'!A1"</span>) <span class='co'># Quotes surround both the file index and the sheet</span></div><div class='output co'>#&gt; # A tibble: 2 x 3
#&gt;   level  type         token
#&gt;   &lt;int&gt; &lt;chr&gt;         &lt;chr&gt;
#&gt; 1     0 sheet '[1]Sheet 1'!
#&gt; 2     0   ref            A1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"'C:\\My Documents\\[file.xlsx]Sheet1'!A1"</span>)</div><div class='output co'>#&gt; # A tibble: 2 x 3
#&gt;   level  type                                    token
#&gt;   &lt;int&gt; &lt;chr&gt;                                    &lt;chr&gt;
#&gt; 1     0 sheet "'C:\\My Documents\\[file.xlsx]Sheet1'!"
#&gt; 2     0   ref                                       A1</div><div class='input'>
<span class='co'># Function names are recognised by the terminal open-parenthesis '('.  There</span>
<span class='co'># is no distinction between custom functions and built-in Excel functions.</span>
<span class='co'># The open-parenthesis is tagged 'fun_open', and the corresponding</span>
<span class='co'># close-parenthesis at the end of the arguments is tagged 'fun_close'.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"MAX(1,2)"</span>)</div><div class='output co'>#&gt; # A tibble: 6 x 3
#&gt;   level      type token
#&gt;   &lt;int&gt;     &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  function   MAX
#&gt; 2     0  fun_open     (
#&gt; 3     1    number     1
#&gt; 4     1 separator     ,
#&gt; 5     1    number     2
#&gt; 6     0 fun_close     )</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"_xll.MY_CUSTOM_FUNCTION()"</span>)</div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level      type                   token
#&gt;   &lt;int&gt;     &lt;chr&gt;                   &lt;chr&gt;
#&gt; 1     0  function _xll.MY_CUSTOM_FUNCTION
#&gt; 2     0  fun_open                       (
#&gt; 3     0 fun_close                       )</div><div class='input'>
<span class='co'># Named ranges (properly called 'named formulas') are a last resort after</span>
<span class='co'># attempting to match a function (ending in an open parenthesis '(') or a</span>
<span class='co'># sheet (ending in an exclamation mark '!')</span>
<span class='fu'>lex_xl</span>(<span class='st'>"MY_NAMED_RANGE"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type          token
#&gt;   &lt;int&gt; &lt;chr&gt;          &lt;chr&gt;
#&gt; 1     0  name MY_NAMED_RANGE</div><div class='input'>
<span class='co'># Some cell addresses/references, functions and names can look alike, but</span>
<span class='co'># lex_xl() should always make the right choice.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"XFD1"</span>)     <span class='co'># A cell in the maximum column in Excel</span></div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   ref  XFD1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"XFE1"</span>)     <span class='co'># Beyond the maximum column, must be a named range/formula</span></div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  name  XFE1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"A1048576"</span>) <span class='co'># A cell in the maximum row in Excel</span></div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type    token
#&gt;   &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;
#&gt; 1     0   ref A1048576</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"A1048577"</span>) <span class='co'># Beyond the maximum row, must be a named range/formula</span></div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type    token
#&gt;   &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;
#&gt; 1     0  name A1048577</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"LOG10"</span>)    <span class='co'># A cell address</span></div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   ref LOG10</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"LOG10()"</span>)  <span class='co'># A log function</span></div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level      type token
#&gt;   &lt;int&gt;     &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  function LOG10
#&gt; 2     0  fun_open     (
#&gt; 3     0 fun_close     )</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"LOG:LOG"</span>)  <span class='co'># The whole column 'LOG'</span></div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type   token
#&gt;   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;
#&gt; 1     0   ref LOG:LOG</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"LOG"</span>)      <span class='co'># Not a cell address, must be a named range/formula</span></div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  name   LOG</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"LOG()"</span>)    <span class='co'># Another log function</span></div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level      type token
#&gt;   &lt;int&gt;     &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  function   LOG
#&gt; 2     0  fun_open     (
#&gt; 3     0 fun_close     )</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"A1.2!A1"</span>)  <span class='co'># A sheet called 'A1.2'</span></div><div class='output co'>#&gt; # A tibble: 2 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0 sheet A1.2!
#&gt; 2     0   ref    A1</div><div class='input'>
<span class='co'># Text is surrounded by double-quotes.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"\"Some text\""</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type           token
#&gt;   &lt;int&gt; &lt;chr&gt;           &lt;chr&gt;
#&gt; 1     0  text "\"Some text\""</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"\"Some \"\"text\"\"\""</span>) <span class='co'># Double-quotes within text are escaped by</span></div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type                   token
#&gt;   &lt;int&gt; &lt;chr&gt;                   &lt;chr&gt;
#&gt; 1     0  text "\"Some \"\"text\"\"\""</div><div class='input'>
<span class='co'># Numbers are signed where it makes sense, and can be scientific</span>
<span class='fu'>lex_xl</span>(<span class='st'>"1"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level   type token
#&gt;   &lt;int&gt;  &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0 number     1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"1.2"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level   type token
#&gt;   &lt;int&gt;  &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0 number   1.2</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"-1"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level   type token
#&gt;   &lt;int&gt;  &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0 number    -1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"-1-1"</span>)</div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level     type token
#&gt;   &lt;int&gt;    &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   number    -1
#&gt; 2     0 operator     -
#&gt; 3     0   number     1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"-1+-1"</span>)</div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level     type token
#&gt;   &lt;int&gt;    &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   number    -1
#&gt; 2     0 operator     +
#&gt; 3     0   number    -1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"MAX(-1-1)"</span>)</div><div class='output co'>#&gt; # A tibble: 7 x 3
#&gt;   level      type token
#&gt;   &lt;int&gt;     &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  function   MAX
#&gt; 2     0  fun_open     (
#&gt; 3     1  operator     -
#&gt; 4     1    number     1
#&gt; 5     1  operator     -
#&gt; 6     1    number     1
#&gt; 7     0 fun_close     )</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"-1.2E-3"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level   type   token
#&gt;   &lt;int&gt;  &lt;chr&gt;   &lt;chr&gt;
#&gt; 1     0 number -1.2E-3</div><div class='input'>
<span class='co'># Booleans can be constants or functions, and names can look like booleans,</span>
<span class='co'># but lex_xl() should always make the right choice.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"TRUE"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  bool  TRUE</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"TRUEISH"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type   token
#&gt;   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;
#&gt; 1     0  name TRUEISH</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"TRUE!A1"</span>)</div><div class='output co'>#&gt; # A tibble: 2 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0 sheet TRUE!
#&gt; 2     0   ref    A1</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"TRUE()"</span>)</div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level      type token
#&gt;   &lt;int&gt;     &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  function  TRUE
#&gt; 2     0  fun_open     (
#&gt; 3     0 fun_close     )</div><div class='input'>
<span class='co'># Errors are tagged 'error'</span>
<span class='fu'>lex_xl</span>(<span class='st'>"#DIV/0!"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type   token
#&gt;   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;
#&gt; 1     0 error #DIV/0!</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"#N/A"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0 error  #N/A</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"#NAME?"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type  token
#&gt;   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;
#&gt; 1     0 error #NAME?</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"#NULL!"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type  token
#&gt;   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;
#&gt; 1     0 error #NULL!</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"#NUM!"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0 error #NUM!</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"#REF!"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type token
#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0 error #REF!</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"#VALUE!"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type   token
#&gt;   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;
#&gt; 1     0 error #VALUE!</div><div class='input'>
<span class='co'># Operators with more than one character are treated as single tokens</span>
<span class='fu'>lex_xl</span>(<span class='st'>"1&lt;&gt;2"</span>)</div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level     type token
#&gt;   &lt;int&gt;    &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   number     1
#&gt; 2     0 operator    &lt;&gt;
#&gt; 3     0   number     2</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"1&lt;=2"</span>)</div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level     type token
#&gt;   &lt;int&gt;    &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   number     1
#&gt; 2     0 operator    &lt;=
#&gt; 3     0   number     2</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"1&lt;2"</span>)</div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level     type token
#&gt;   &lt;int&gt;    &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   number     1
#&gt; 2     0 operator     &lt;
#&gt; 3     0   number     2</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"1=2"</span>)</div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level     type token
#&gt;   &lt;int&gt;    &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   number     1
#&gt; 2     0 operator     =
#&gt; 3     0   number     2</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"1&amp;2"</span>)</div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level     type token
#&gt;   &lt;int&gt;    &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   number     1
#&gt; 2     0 operator     &amp;
#&gt; 3     0   number     2</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"1 2"</span>)</div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level     type token
#&gt;   &lt;int&gt;    &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   number     1
#&gt; 2     0 operator      
#&gt; 3     0   number     2</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"(1,2)"</span>)</div><div class='output co'>#&gt; # A tibble: 5 x 3
#&gt;   level        type token
#&gt;   &lt;int&gt;       &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  paren_open     (
#&gt; 2     1      number     1
#&gt; 3     1    operator     ,
#&gt; 4     1      number     2
#&gt; 5     0 paren_close     )</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"1%"</span>)   <span class='co'># postfix operator</span></div><div class='output co'>#&gt; # A tibble: 2 x 3
#&gt;   level     type token
#&gt;   &lt;int&gt;    &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0   number     1
#&gt; 2     0 operator     %</div><div class='input'>
<span class='co'># The union operator is a comma ',', which is the same symbol that is used</span>
<span class='co'># to separate function arguments or array columns.  It is tagged 'operator'</span>
<span class='co'># only when it is inside parentheses that are not function parentheses or</span>
<span class='co'># array curly braces.  The curly braces are tagged 'array_open' and</span>
<span class='co'># 'array_close'.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"A1,B2"</span>) <span class='co'># invalid formula, defaults to 'union' to avoid a crash</span></div><div class='output co'>#&gt; # A tibble: 3 x 3
#&gt;   level     type token
#&gt;   &lt;int&gt;    &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0      ref    A1
#&gt; 2     0 operator     ,
#&gt; 3     0      ref    B2</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"(A1,B2)"</span>)</div><div class='output co'>#&gt; # A tibble: 5 x 3
#&gt;   level        type token
#&gt;   &lt;int&gt;       &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  paren_open     (
#&gt; 2     1         ref    A1
#&gt; 3     1    operator     ,
#&gt; 4     1         ref    B2
#&gt; 5     0 paren_close     )</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"MAX(A1,B2)"</span>)</div><div class='output co'>#&gt; # A tibble: 6 x 3
#&gt;   level      type token
#&gt;   &lt;int&gt;     &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  function   MAX
#&gt; 2     0  fun_open     (
#&gt; 3     1       ref    A1
#&gt; 4     1 separator     ,
#&gt; 5     1       ref    B2
#&gt; 6     0 fun_close     )</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"SMALL((A1,B2),1)"</span>)</div><div class='output co'>#&gt; # A tibble: 10 x 3
#&gt;    level        type token
#&gt;    &lt;int&gt;       &lt;chr&gt; &lt;chr&gt;
#&gt;  1     0    function SMALL
#&gt;  2     0    fun_open     (
#&gt;  3     1  paren_open     (
#&gt;  4     2         ref    A1
#&gt;  5     2    operator     ,
#&gt;  6     2         ref    B2
#&gt;  7     1 paren_close     )
#&gt;  8     1   separator     ,
#&gt;  9     1      number     1
#&gt; 10     0   fun_close     )</div><div class='input'>
<span class='co'># Function arguments are separated by commas ',', which are tagged</span>
<span class='co'># 'separator'.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"MAX(1,2)"</span>)</div><div class='output co'>#&gt; # A tibble: 6 x 3
#&gt;   level      type token
#&gt;   &lt;int&gt;     &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  function   MAX
#&gt; 2     0  fun_open     (
#&gt; 3     1    number     1
#&gt; 4     1 separator     ,
#&gt; 5     1    number     2
#&gt; 6     0 fun_close     )</div><div class='input'>
<span class='co'># Nested functions are marked by an increase in the 'level'.  The level</span>
<span class='co'># increases inside parentheses, rather than at the parentheses.  Curly</span>
<span class='co'># braces, for arrays, have the same behaviour, as do subexpressions inside</span>
<span class='co'># ordinary parenthesis, tagged 'paren_open' and 'paren_close'.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"MAX(MIN(1,2),3)"</span>)</div><div class='output co'>#&gt; # A tibble: 11 x 3
#&gt;    level      type token
#&gt;    &lt;int&gt;     &lt;chr&gt; &lt;chr&gt;
#&gt;  1     0  function   MAX
#&gt;  2     0  fun_open     (
#&gt;  3     1  function   MIN
#&gt;  4     1  fun_open     (
#&gt;  5     2    number     1
#&gt;  6     2 separator     ,
#&gt;  7     2    number     2
#&gt;  8     1 fun_close     )
#&gt;  9     1 separator     ,
#&gt; 10     1    number     3
#&gt; 11     0 fun_close     )</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"{1,2;3,4}"</span>)</div><div class='output co'>#&gt; # A tibble: 9 x 3
#&gt;   level        type token
#&gt;   &lt;int&gt;       &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  open_array     {
#&gt; 2     1      number     1
#&gt; 3     1   separator     ,
#&gt; 4     1      number     2
#&gt; 5     1   separator     ;
#&gt; 6     1      number     3
#&gt; 7     1   separator     ,
#&gt; 8     1      number     4
#&gt; 9     0 close_array     }</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"1*(2+3)"</span>)</div><div class='output co'>#&gt; # A tibble: 7 x 3
#&gt;   level        type token
#&gt;   &lt;int&gt;       &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0      number     1
#&gt; 2     0    operator     *
#&gt; 3     0  paren_open     (
#&gt; 4     1      number     2
#&gt; 5     1    operator     +
#&gt; 6     1      number     3
#&gt; 7     0 paren_close     )</div><div class='input'>
<span class='co'># Arrays are marked by opening and closing curly braces, with comma ','</span>
<span class='co'># between columns, and semicolons ';' between rows  Commas and semicolons are</span>
<span class='co'># both tagged 'separator'.  Arrays contain only constants, which are</span>
<span class='co'># booleans, numbers, text, and errors.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"MAX({1,2;3,4})"</span>)</div><div class='output co'>#&gt; # A tibble: 12 x 3
#&gt;    level        type token
#&gt;    &lt;int&gt;       &lt;chr&gt; &lt;chr&gt;
#&gt;  1     0    function   MAX
#&gt;  2     0    fun_open     (
#&gt;  3     1  open_array     {
#&gt;  4     2      number     1
#&gt;  5     2   separator     ,
#&gt;  6     2      number     2
#&gt;  7     2   separator     ;
#&gt;  8     2      number     3
#&gt;  9     2   separator     ,
#&gt; 10     2      number     4
#&gt; 11     1 close_array     }
#&gt; 12     0   fun_close     )</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"=MAX({-1E-2,TRUE;#N/A,\"Hello, World!\"})"</span>)</div><div class='output co'>#&gt; # A tibble: 13 x 3
#&gt;    level        type               token
#&gt;    &lt;int&gt;       &lt;chr&gt;               &lt;chr&gt;
#&gt;  1     0    operator                   =
#&gt;  2     0    function                 MAX
#&gt;  3     0    fun_open                   (
#&gt;  4     1  open_array                   {
#&gt;  5     2      number               -1E-2
#&gt;  6     2   separator                   ,
#&gt;  7     2        bool                TRUE
#&gt;  8     2   separator                   ;
#&gt;  9     2       error                #N/A
#&gt; 10     2   separator                   ,
#&gt; 11     2        text "\"Hello, World!\""
#&gt; 12     1 close_array                   }
#&gt; 13     0   fun_close                   )</div><div class='input'>
<span class='co'># Structured references are surrounded by square brackets.  Subexpressions</span>
<span class='co'># may also be surrounded by square brackets, but lex_xl() returns the whole</span>
<span class='co'># expression in a single 'structured_ref' token.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"[@col2]"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level           type   token
#&gt;   &lt;int&gt;          &lt;chr&gt;   &lt;chr&gt;
#&gt; 1     0 structured_ref [@col2]</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"SUM([col22])"</span>)</div><div class='output co'>#&gt; # A tibble: 4 x 3
#&gt;   level           type   token
#&gt;   &lt;int&gt;          &lt;chr&gt;   &lt;chr&gt;
#&gt; 1     0       function     SUM
#&gt; 2     0       fun_open       (
#&gt; 3     1 structured_ref [col22]
#&gt; 4     0      fun_close       )</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"Table1[col1]"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level           type        token
#&gt;   &lt;int&gt;          &lt;chr&gt;        &lt;chr&gt;
#&gt; 1     0 structured_ref Table1[col1]</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"Table1[[col1]:[col2]]"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level           type                 token
#&gt;   &lt;int&gt;          &lt;chr&gt;                 &lt;chr&gt;
#&gt; 1     0 structured_ref Table1[[col1]:[col2]]</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"Table1[#Headers]"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level           type            token
#&gt;   &lt;int&gt;          &lt;chr&gt;            &lt;chr&gt;
#&gt; 1     0 structured_ref Table1[#Headers]</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"Table1[[#Headers],[col1]]"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level           type                     token
#&gt;   &lt;int&gt;          &lt;chr&gt;                     &lt;chr&gt;
#&gt; 1     0 structured_ref Table1[[#Headers],[col1]]</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"Table1[[#Headers],[col1]:[col2]]"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level           type                            token
#&gt;   &lt;int&gt;          &lt;chr&gt;                            &lt;chr&gt;
#&gt; 1     0 structured_ref Table1[[#Headers],[col1]:[col2]]</div><div class='input'>
<span class='co'># DDE calls (Dynamic Data Exchange) are normalized by Excel into indexes.</span>
<span class='co'># Either way, lex_xl() includes everything in one token.</span>
<span class='fu'>lex_xl</span>(<span class='st'>"[1]!'DDE_parameter=1'"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type                 token
#&gt;   &lt;int&gt; &lt;chr&gt;                 &lt;chr&gt;
#&gt; 1     0   DDE [1]!'DDE_parameter=1'</div><div class='input'><span class='fu'>lex_xl</span>(<span class='st'>"'Quote'|'NYSE'!ZAXX"</span>)</div><div class='output co'>#&gt; # A tibble: 1 x 3
#&gt;   level  type               token
#&gt;   &lt;int&gt; &lt;chr&gt;               &lt;chr&gt;
#&gt; 1     0   DDE 'Quote'|'NYSE'!ZAXX</div><div class='input'><span class='co'># Meaningless spaces that appear in some old files are returned as 'space'</span>
<span class='co'># tokens, so that the original formula can still be recovered by</span>
<span class='co'># concatenating all the tokens.  Spaces between function names and their open</span>
<span class='co'># parenthesis have not been observed, so are not permitted.</span>
<span class='fu'>lex_xl</span>(<span class='st'>" MAX( A1 ) "</span>)</div><div class='output co'>#&gt; # A tibble: 8 x 3
#&gt;   level      type token
#&gt;   &lt;int&gt;     &lt;chr&gt; &lt;chr&gt;
#&gt; 1     0  operator      
#&gt; 2     0  function   MAX
#&gt; 3     0  fun_open     (
#&gt; 4     1  operator      
#&gt; 5     1       ref    A1
#&gt; 6     1  operator      
#&gt; 7     0 fun_close     )
#&gt; 8     0  operator      </div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#value">Value</a></li>

      <li><a href="#details">Details</a></li>

      <li><a href="#see-also">See also</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Duncan Garmonsway.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  </body>
</html>
